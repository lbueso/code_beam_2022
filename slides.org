#+title: Improve your tests with Makina
#+author: Luis Eduardo Bueso de Barrio
#+setupfile: slides.setup
#+options: title:nil

\texturetheme

#+begin_export latex
\setbeamertemplate{title page}{
    \begin{columns}
      \begin{column}{0.55\textwidth}
        \center
        \includegraphics[width=\textwidth]{./template/logo-white}
      \end{column}
      \begin{column}{0.40\textwidth}
        \flushright
            {\Huge STOCKHOLM}

            \vspace{0.2cm}

            {\large HYBRID CONFERENCE}

            \vspace{1cm}

            {\Large \texttt{Improve your tests with Makina}}

            \vspace{1cm}

            Luis Eduardo Bueso de Barrio

            \vspace{0.5cm}

            \texttt{May 20 | 2022}
      \end{column}
    \end{columns}
}
#+end_export

\maketitle

\whitetheme

* Motivation
** 
*** column
:properties:
:beamer_col: 0.38
:end:

Before:
| files | blank | comment | code |
|-------+-------+---------+------|
|     4 |   760 |     383 | 4513 |
*** column
:properties:
:beamer_col: 0.38
:end:

After:
| files | blank | comment | code |
|-------+-------+---------+------|
|    18 |   500 |     408 | 1692 |

** PBT models
*** column
:properties:
:beamer_col: 0.48
:end:

Proprety-Based Testing (PBT) is a great testing methodology.

\vspace{10pt}

Successful tools widely used:
- Erlang QuickCheck (EQC)
- PropEr

\vspace{10pt}

These tools are great for testing pure functions.

\vspace{10pt}

They have mechanisms to test stateful programs.

\vspace{10pt}

PBT state-machines or models.

# TODO: figure

*** column
:properties:
:beamer_col: 0.48
:end:

A PBT model works like an oracle.

\vspace{10pt}

** Problems with PBT models

Despite their proven effectiveness:
- Very slow adoption

\vspace{10pt}

Why?

\vspace{10pt}

1. Models are hard to reuse.
2. Bugs in models are hard to detect.
3. Errors are hard to understand.

\vspace{10pt}

All these problems made models hard to write and maintain.

* Introduction to Makina and running example
** Our solution: Makina
*** column
:properties:
:beamer_col: 0.48
:end:

Makina is a DSL for writing PBT models.

# TODO: diagram that shows that the user writes a model and then Makina translates it to a
# EQC/PropEr state-machine.

\vspace{10pt}

*** column
:properties:
:beamer_col: 0.48
:end:

1. Models are hard to reuse.
   - Model refinement and composition. \vspace{10pt}
2. Bugs in models are hard to detect.
   - Automatic type and specs generation. \vspace{10pt}
3. Errors are hard to understand.
   - Automatic generation of runtime-checks. \vspace{10pt}

** Makina: The Language
*** column
:properties:
:beamer_col: 0.38
:end:

#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Name do
    use Makina, [_option_]

    state [_attribute_]

    invariants [_invariants_]

    command _declaration_ do
      _command_body_
    end
  end
#+end_src

#+attr_latex: :options style=display

~_option_~
- ~extends: module()~
- ~extends: [module()]~
- ~implemented_by: module()~

*** column
:properties:
:beamer_col: 0.58
:end:

~_attribute_~
- ~name: expr~
- ~name: expr  type~

\vspace{10pt}
~_declaration_~
- ~name(arg1, ... , argN)~
- ~name(arg1 type1, ... , argN typeN) return_type~

\vspace{10pt}
~_command_body_~
| name | access                   | returns     |
|------+--------------------------+-------------|
| ~pre~  | state                    | ~boolean()~   |
| ~args~ | state                    | ~generator()~ |
| ~call~ | arguments                | ~return_type~ |
| ~next~ | state, arguments, result | ~[updates()]~ |
| ~post~ | state, arguments, result | ~boolean()~   |

** Ethereum Blockchain
*** column
:properties:
:beamer_col: 0.48
:end:

Why Ethereum?
- It is a complex system.

\vspace{10pt}  
  
The properties to test:
#+beamer: \onslide<+->
1. Mining blocks.
   #+beamer: \onslide<+->
2. Account access.
   #+beamer: \onslide<+->
3. Transactions between accounts.

*** column
:properties:
:beamer_col: 0.48
:end:

| API                    |
|------------------------|
| ~accounts/0~             |
| ~block_number/0~         |
| ~call_transaction/4~     |
| ~client_version/0~       |
| ~compile_solidity/1~     |
| ~deploy/3~               |
| ~deploy/4~               |
| ~estimate_gas/4~         |
| ~estimate_gas_cost/4~    |
| ~gas_cost/1~             |
| ~gas_price/0~            |
| ~get_balance/1~          |
| ~get_block/0~            |
| ~get_block/1~            |
| ~get_bytecode/1~         |
| ~get_contract_address/1~ |
| ...


* Blocks model
** Mining blocks
*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<+->
#+beamer: \onslide<+->
The API:
#+beamer: \onslide<+->
| Command        | Returns          |
|----------------+------------------|
| ~mine/0~         | ~:ok~              |
| ~block_number/0~ | ~integer()~        |
#+beamer: \onslide<+->
\vspace{10pt}
1. create module.
   #+beamer: \onslide<+->
2. import ~Makina~.
   #+beamer: \onslide<+->
3. define state.
   #+beamer: \onslide<+->
4. define invariants.
   #+beamer: \onslide<+->
5. define commands.

*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<4->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do #@ \onslide<5->
    use Makina
    #@ \onslide<6->
    state height: 0
    #@ \onslide<7->
    invariants non_neg_height: height > 0
    #@ \onslide<8->
    command block_number() do #@ \onslide<9->
      pre true #@ \onslide<10->
      args [] #@ \onslide<11->
      call Etherex.block_number #@ \onslide<12->
      next [] #@ \onslide<13->
      post height == result #@ \onslide<14->
    end
#+end_src

** Mining blocks
*** column
:properties:
:beamer_col: 0.48
:end:

The API:

| Command        | Returns   |
|----------------+-----------|
| ~mine/0~         | ~:ok~       |
| ~block_number/0~ | ~integer()~ |

\vspace{10pt}
1. create module.
2. import ~Makina~.
3. define state.
4. define invariants.
5. define commands.

*** column
:properties:
:beamer_col: 0.48
:end:
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height > 0

    command block_number() do
      post height == result
    end
    #@ \onslide<2->
    command mine() do
      next height: height + 1
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test
  #@ \onslide<+->
  Failed! After 1 tests.

  Postcondition crashed:
  ,** invariant "non_neg_height" check failed

  block_number/0

  Last state: %{height: 0}
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height > 0

    command block_number() do
      post height == result
    end

    command mine() do
      next height: height + 1
    end
  end
#+end_src

** Fixing the model

*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test

  Failed! After 1 tests.

  Postcondition crashed:
  ,** invariant "non_neg_height" check failed

  block_number/0

  Last state: %{height: 0}
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height >#@\only<2->{=} 0

    command block_number() do
      post height == result
    end

    command mine() do
      next height: height + 1
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.48
:end:

#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->
  #@\onslide<+->
  ..................................................
  ..................................................

  OK, passed 100 tests

  51.5 mine/0
  48.5 block_number/0
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height >= 0

    command block_number() do
      post height == result
    end

    command mine() do
      next height: height + 1
    end
  end
#+end_src

** Adding type information
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<3->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix gradient

  $
#+end_src

\vspace{10pt}
#+beamer: \onslide<4->
Something changes in =Etherex=...

\vspace{10pt}

#+beamer: \onslide<5->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix gradient

  The function call Etherex.block_number()
  on line 8 is expected to have type integer()
  but it has type
  {:ok, quantity()} | {:error, error()}

  $
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display, numbers=left
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0 #@\only<2->{:: integer()}

    invariants non_neg_height: height >= 0

    command block_number()#@\only<2->{ :: integer()} do
      post height == result
    end

    command mine()#@\only<2->{ :: :ok} do
      next height: height + 1
    end
  end
#+end_src

** Adding documentation

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<3->
#+attr_latex: :options style=shell
#+begin_src bash
  iex> h Blocks
  #@\onslide<4->
  Contains a Makina model called Blocks.

  Checks blocks are mined correctly.

  ## Commands

  - mine
  - block_number

  ## State attributes

  - height

  ## Invariants

  - non_neg_height
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex
    #@ \onslide<2->
    @moduledoc """
    Checks blocks are mined correctly.
    """ #@ \onslide<1->
    state height: 0 :: integer()

    invariants non_neg_height: height >= 0

    command block_number() :: integer() do #@ \onslide<2->
      @moduledoc "Gets the block number." #@ \onslide<1->
      post {:ok, height} == result
    end

    command mine() :: :ok do #@ \onslide<2->
      @moduledoc "Mines a new block." #@ \onslide<1->
      next height: height + 1
    end
  end
#+end_src

** Adding documentation
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=shell
#+begin_src bash
  iex> h Blocks.Command.Mine
  #@\onslide<2->
  This module contains the functions necessary to
  generate and execute the command mine.

  Mines a new block.

  ## Definitions

  - next
  - call
  - weight
  - post
  - args
  - pre
#+end_src
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    @moduledoc """
    Checks blocks are mined correctly.
    """
    state height: 0 :: integer()

    invariants non_neg_height: height >= 0

    command block_number() :: integer() do
      @moduledoc "Gets the block number."
      post {:ok, height} == result
    end

    command mine() :: :ok do
      @moduledoc "Mines a new block."
      next height: height + 1
    end
  end
#+end_src

** Adding documentation

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=shell
#+begin_src bash
  iex> h Blocks.Command.Mine.post
  #@\onslide<2->
  This definition contains a predicate that should
  be true after the execution of mine

  ## Available variables

  ### State

  - state
  - height

  ### Arguments

  - arguments

  ### Result

  - result
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    @moduledoc """
    Checks blocks are mined correctly.
    """
    state height: 0 :: integer()

    invariants non_neg_height: height >= 0

    command block_number() :: integer() do
      @moduledoc "Gets the block number."
      post {:ok, height} == result
    end

    command mine() :: :ok do
      @moduledoc "Mines a new block."
      next height: height + 1
    end
  end
#+end_src

* Accounts model
** Account access
*** column
:properties:
:beamer_col: 0.28
:end:
#+beamer: \onslide<+->
The API:

| Command   | Returns   |
|-----------+-----------|
| ~balance/1~ | ~integer()~ |
#+beamer: \onslide<+->
\vspace{0.5cm}
1. create module.
   #+beamer: \onslide<+->
2. import ~Makina~.
   #+beamer: \onslide<+->
3. define state.
   #+beamer: \onslide<+->
5. define commands.

*** column
:properties:
:beamer_col: 0.59
:end:

#+beamer: \onslide<2->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Accounts do #@\onslide<3->
    use Makina, implemented_by: Etherex
    #@\onslide<4->
    @type balances() :: %{address() => integer()}

    state accounts: Etherex.accounts() :: [address()],
          balances: Etherex.balances() :: balances()
    #@\onslide<5->
    command balance(account :: address()) :: integer() do
      pre accounts != []
      post balances[account] == result
    end #@\onslide<2->
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.28
:end:

#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test
  #@\onslide<+->
  ,** (Makina.Error) argument
  `account` missing in command
  get_balance
#+end_src
\vspace{40pt}

*** column
:properties:
:beamer_col: 0.58
:end:

#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Accounts do
    use Makina, implemented_by: Etherex

    @type balances() :: %{address() => integer()}

    state accounts: Etherex.accounts() :: [address()],
          balances: Etherex.balances() :: balances()

    command balance(account :: address()) :: integer() do
      pre accounts != []
      post balances[account] == result
    end
  end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.28
:end:

#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test

  ,** (Makina.Error) argument
  `account` missing in command
  get_balance
#+end_src
\vspace{40pt}

*** column
:properties:
:beamer_col: 0.58
:end:

#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Accounts do
    use Makina, implemented_by: Etherex

    @type balances() :: %{address() => integer()}

    state accounts: Etherex.accounts() :: [address()],
          balances: Etherex.balances() :: balances()

    command balance(account :: address()) :: integer() do
      args account: oneof(accounts)
      pre accounts != []
      post balances[account] == result
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.28
:end:

#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->
  #@\onslide<+->
  .........................
  .........................
  .........................
  .........................
  OK, passed 100 tests

  '100.0 get_balance/1
#+end_src

*** column
:properties:
:beamer_col: 0.58
:end:

#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Accounts do
    use Makina, implemented_by: Etherex
    @type balances() :: %{address() => integer()}

    state accounts: Etherex.accounts() :: [address()],
          balances: Etherex.balances() :: balances()

    command balance(account :: address()) :: integer() do
      args account: oneof(accounts)
      pre accounts != []
      post balances[account] == result
    end
  end
#+end_src

* Transactions model
** Generating transactions
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
The API to generate and check transactions:
#+beamer: \onslide<+->
| Command        | Returns   |
|----------------+-----------|
| ~mine/0~         | ~:ok~       |
| ~block_number/0~ | ~integer()~ |
| ~get_balance/1~  | ~integer()~ |
| ~transfer/3~     | ~hash()~    |
#+beamer: \onslide<+->
We can compose ~Blocks~ and ~Accounts~!
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      extends: [Blocks, Accounts],
      implemented_by: Etherex
  end
#+end_src
#+beamer: \onslide<+->
Generates a model ~Transactions.Composed~.

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  iex(1)> h Transactions.Composed
  #@\onslide<+->
  # Transactions.Composed

  ## Commands

  - mine stored
  - get_balance
  - block_number

  ## State attributes

  - height
  - balances
  - accounts

  ## Invariants

  - non_neg_height

#+end_src

** Generating transactions
*** column
:properties:
:beamer_col: 0.44
:end:
#+beamer: \onslide<+->
| Command        | Returns   |
|----------------+-----------|
| =transfer/3=     | =hash()=    |
*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next balances: update(balances, from, to, value)
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.44
:end:
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->

  transfer("0xffcf8fdee72ac11",
           "0x90f8bf6a479f320",
           1)
  block_number()

  Postcondition failed.

  block_number() -> {:ok, 1}

  Last state: %{height: 0, ...}
#+end_src

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next balances: update(balances, from, to, value)
    end
  end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.44
:end:
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->

  Postcondition failed.

  transfer("0xffcf8fdee72ac11",
           "0x90f8bf6a479f320",
           1)
  block_number() -> {:ok, 1}

  Last state: %{height: 0, ...}
#+end_src

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next height: height + 1,
           balances: update(balances, from, to, value)
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.44
:end:
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->

  transfer("0x90f8bf6a479f320",
           "0x90f8bf6a479f320",
           1),
  get_balance("0x90f8bf6a479f320")

  Postcondition failed.

  get_balance("0x90f8bf6a479f320")
  -> {:ok, 979000}

  Last state: %{
      balances: %{
          "0x90f8bf6a479f320" => 1000000
          .. }
      .. }
#+end_src

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next height: height + 1,
           balances: update(balances, from, to, value)
    end
  end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.44
:end:

To fix this error we need to extract the gas cost after producing a transaction.

\vspace{10pt}

Model execution is performed in two phases:
1. Generation of the command sequence.
2. Real execution of the test.

\vspace{10pt}

PBT libraries make this difference in documentation:
- symbolic state: state of the model during phase 1.
- dynamic state: state of the model during phase 2.

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next height: height + 1,
           balances: update(balances, from, to, value)
    end
  end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.44
:end:

~Makina~ makes the difference between symbolic and dynamic explicit.

\vspace{10pt}

Provides two mechanisms to add information about symbolic state:
- ~symbolic(t)~ type.
- ~symbolic(expr)~ macro.

Rules on symbolic state:
- An attribute with a symbolic type cannot be inspected in ~next~.
- If we need to update a symbolic attribute we should use symbolic macro.
  
\vspace{10pt}

To fix our model we need
1. Add symbolic attributes to the state.
2. Store and update symbolic attributes.

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
\vspace{-10pt}
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    state transactions: [] :: [symbolic(hash())]
          balances: super() :: symbolic(balances)
  
    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next height: height + 1,
           transactions: [result | transactions],
           balances: update(balances, from, to, value)
                     |> symbolic()
    end

    command get_balance() do
      pre transactions == []
    end
  end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.38
:end:

We import ~Transactions~ model using ~:extends~.

\vspace{10pt}

We add a command that gets the cost of a transaction.

*** column
:properties:
:beamer_col: 0.58
:end:

#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions.GasCost do
    use Makina, extends: Transactions

    command gas_cost(hash :: hash())
        :: {address(), quantity()} do
      pre transactions != []
      args hash: oneof(transactions)
      next transactions: List.delete(transactions, hash),
           balances: update_gas(balances, result)
                     |> symbolic()
      end
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.38
:end:

#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test

  .........................
  .........................
  .........................
  .........................

  OK, passed 100 tests

  '25.5 mine/0
  '24.9 block_number/0
  '23.6 transfer/3
  '14.3 gas_cost/1
  '11.8 get_balance/1
#+end_src

*** column
:properties:
:beamer_col: 0.58
:end:

#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions.GasCost do
    use Makina, extends: Transactions

    command gas_cost(hash :: hash())
        :: {address(), quantity()} do
      pre transactions != []
      args hash: oneof(transactions)
      next transactions: List.delete(transactions, hash),
           balances: update_gas(balances, result)
                     |> symbolic()
      end
    end
  end
#+end_src
* Conclusions
** Results

We presented a modular approach to write testing models using ~Makina~.

\vspace{10pt}

~Makina~ empowers programmers to write better tests using PBT libraries.

\vspace{10pt}

| Problem on PBT models               | ~Makina~ solution                              |
|-------------------------------------+----------------------------------------------|
| PBT models are hard to reuse.       | ~:extends~, ~imports~ and ~composition~ operations |
|                                     |                                              |
| PBT models bugs are hard to detect. | Automatic generation of type information.    |
|                                     |                                              |
| PBT models generate cryptic errors. | Automatic generation of runtime checks.      |


