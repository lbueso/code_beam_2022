#+title: Improve your tests with Makina
#+author: Luis Eduardo Bueso de Barrio
#+setupfile: slides.setup
#+options: title:nil

\texturetheme

#+begin_export latex
\setbeamertemplate{title page}{
    \begin{columns}
      \begin{column}{0.55\textwidth}
        \center
        \includegraphics[width=\textwidth]{./template/logo-white}
      \end{column}
      \begin{column}{0.40\textwidth}
        \flushright
            {\Huge STOCKHOLM}

            \vspace{0.2cm}

            {\large HYBRID CONFERENCE}

            \vspace{1cm}

            {\Large \texttt{Improve your tests with Makina}}

            \vspace{1cm}

            Luis Eduardo Bueso de Barrio

            \vspace{0.5cm}

            \texttt{May 20 | 2022}
      \end{column}
    \end{columns}
}
#+end_export

\maketitle

\whitetheme

* Motivation
** 
*** column
:properties:
:beamer_col: 0.38
:end:
  
Before:
| files | blank | comment | code |
|-------+-------+---------+------|
|     4 |   760 |     383 | 4513 |
*** column
:properties:
:beamer_col: 0.38
:end:

After:
| files | blank | comment | code |
|-------+-------+---------+------|
|    18 |   500 |     408 | 1692 |

** PBT models

*** column
:properties:
:beamer_col: 0.48
:end:

Proprety-Based Testing (PBT) is a great testing methodology.

\vspace{10pt}

Successful tools widely used:
- Erlang QuickCheck (EQC)
- PropEr

\vspace{10pt}

These tools are great for testing pure functions.

\vspace{10pt}

They have mechanisms to test stateful programs.

\vspace{10pt}

PBT state-machines or models.

# TODO: figure

*** column
:properties:
:beamer_col: 0.48
:end:

A PBT model is like an oracle.

\vspace{10pt}

** Problems with PBT models

Despite their proven effectiveness:
- Very slow adoption

\vspace{10pt}

Why?

\vspace{10pt}

1. Models are hard to reuse.
2. Bugs in models are hard to detect.
3. Errors are hard to understand.

\vspace{10pt}

All these problems made models hard to write and maintain.

* Introduction to Makina and running example
** Our solution: Makina
*** column
:properties:
:beamer_col: 0.48
:end:

Makina is a DSL for writing PBT models.

# TODO: diagram that shows that the user writes a model and then Makina translates it to a
# EQC/PropEr state-machine.

\vspace{10pt}

*** column
:properties:
:beamer_col: 0.48
:end:

1. Models are hard to reuse.
   - Model refinement and composition. \vspace{10pt}
2. Bugs in models are hard to detect.
   - Automatic type and specs generation. \vspace{10pt}
3. Errors are hard to understand.
   - Automatic generation of runtime-checks. \vspace{10pt}

** Introduction to Makina
** Ethereum Blockchain

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
A blockchain is a distributed ledger that enables peer-to-peer transactions.
#+beamer: \onslide<+->
#+begin_figure latex
\begin{adjustbox}{max width=\textwidth}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
    distance=20,semithick, minimum width=70]

    \node (block0name) {\begin{tabular}{c} Block 0 \\ Genesis Block \end{tabular}};
    \node[rectangle, draw, below of=block0name] (block0index) {Index};
    \node[rectangle, draw, below of=block0index] (block0timestamp) {Timestamp};
    \node[rectangle, draw, below of=block0timestamp] (block0previoushash)
    {Previous Hash};
    \node[rectangle, draw, below of=block0previoushash] (block0hash)
    {Hash};
    \node[rectangle, draw, below of=block0hash] (block0data)
    {Data};

    \node [right of=block0name, yshift=-20, xshift=80] (block1name) {Block 1};
    \node[rectangle, draw, below of=block1name] (block1index) {Index};
    \node[rectangle, draw, below of=block1index] (block1timestamp) {Timestamp};
    \node[rectangle, draw, below of=block1timestamp] (block1previoushash)
    {Previous Hash};
    \node[rectangle, draw, below of=block1previoushash] (block1hash)
    {Hash};
    \node[rectangle, draw, below of=block1hash] (block1data)
    {Data};

    % \node [right of=block1name, yshift=-20, xshift=80] (block2name) {Block 2};
    % \node[rectangle, draw, below of=block2name] (block2index) {Index};
    % \node[rectangle, draw, below of=block2index] (block2timestamp) {Timestamp};
    % \node[rectangle, draw, below of=block2timestamp] (block2previoushash)
    % {Previous Hash};
    % \node[rectangle, draw, below of=block2previoushash] (block2hash)
    % {Hash};
    % \node[rectangle, draw, below of=block2hash] (block2data)
    % {Data};

    \node[right of=block1hash, xshift=40, minimum width=20] (block2previoushash)
    {...};

    \draw (block1previoushash) edge (block0hash);
    \draw (block2previoushash) edge (block1hash);

    \node[left  of=block0name, xshift=-20, yshift= 15] (block0a) {};
    \node[right of=block0data, xshift= 20, yshift=-13] (block0b) {};
    \draw[draw] (block0a) rectangle (block0b);

    \node[left  of=block1name, xshift=-20, yshift= 10] (block1a) {};
    \node[right of=block1data, xshift= 20, yshift=-13] (block1b) {};
    \draw[draw] (block1a) rectangle (block1b);

    % \node[left  of=block2name, xshift=-20, yshift= 10] (block2a) {};
    % \node[right of=block2data, xshift= 20, yshift=-10] (block2b) {};
    % \draw[draw] (block2a) rectangle (block2b);

  \end{tikzpicture}
\end{adjustbox}
#+end_figure

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
Why Ethereum?
#+beamer: \onslide<+->
- Big community.
  #+beamer: \onslide<+->
- Multiple implementations.
  #+beamer: \onslide<+->
\vspace{10pt}

To interact we will use =etherex=:
#+beamer: \onslide<+->
https://gitlab.com/babel-upm/blockchain/etherex

#+beamer: \onslide<+->
\vspace{10pt}

The properties to test:
#+beamer: \onslide<+->
1. Mining blocks.
   #+beamer: \onslide<+->
2. Account access.
   #+beamer: \onslide<+->
3. Transactions between accounts.

* Blocks model
** Mining blocks
*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<+->
#+beamer: \onslide<+->
The API:
#+beamer: \onslide<+->
| Command        | Returns          |
|----------------+------------------|
| =mine/0=         | =:ok=              |
| =block_number/0= | =integer()=        |
#+beamer: \onslide<+->
\vspace{10pt}
1. create module.
   #+beamer: \onslide<+->
2. import =Makina=.
   #+beamer: \onslide<+->
3. define state.
   #+beamer: \onslide<+->
4. define invariants.
   #+beamer: \onslide<+->
5. define commands.

*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<4->
#+attr_latex: :options style=display
#+begin_src elixir
    defmodule Blocks do #@ \onslide<5->
      use Makina
      #@ \onslide<6->
      state height: 0
      #@ \onslide<7->
      invariants non_neg_height: height > 0
      #@ \onslide<8->
      command block_number() do #@ \onslide<9->
        pre true #@ \onslide<10->
        args [] #@ \onslide<11->
        call Etherex.block_number #@ \onslide<12->
        next [] #@ \onslide<13->
        post height == result #@ \onslide<14->
      end
#+end_src

** Mining blocks

*** column
:properties:
:beamer_col: 0.48
:end:

The API:

| Command        | Returns   |
|----------------+-----------|
| =mine/0=         | =:ok=       |
| =block_number/0= | =integer()= |

\vspace{10pt}
1. create module.
2. import =Makina=.
3. define state.
4. define invariants.
5. define commands.

*** column
:properties:
:beamer_col: 0.48
:end:
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height > 0

    command block_number() do
      post height == result
    end
    #@ \onslide<2->
    command mine() do
      next height: height + 1
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test
  #@ \onslide<+->
  Failed! After 1 tests.

  Postcondition crashed:
  ,** invariant "non_neg_height" check failed

  Shrinking x.(1 times)
  [
      Blocks.block_number/0
  ]

  Last state: %{height: 0}
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height > 0

    command block_number() do
      post height == result
    end

    command mine() do
      next height: height + 1
    end
  end
#+end_src

** Fixing the model

*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test

  Failed! After 1 tests.

  Postcondition crashed:
  ,** invariant "non_neg_height" check failed

  Shrinking x.(1 times)
  [
      Blocks.block_number/0
  ]

  Last state: %{height: 0}
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height >#@\only<2->{=} 0

    command block_number() do
      post height == result
    end

    command mine() do
      next height: height + 1
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.48
:end:

#+attr_latex: :options style=shell
#+begin_src bash
    $ mix test #@\onslide<+->
    #@\onslide<+->
    ..................................................
    ..................................................

    OK, passed 100 tests

    51.5 Blocks.mine/0
    48.5 Blocks.block_number/0
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height >= 0

    command block_number() do
      post height == result
    end

    command mine() do
      next height: height + 1
    end
  end
#+end_src

** Adding type information
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<3->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix gradient

  $
#+end_src

\vspace{10pt}
#+beamer: \onslide<4->
Something changes in =Etherex=...

\vspace{10pt}

#+beamer: \onslide<5->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix gradient

  The function call Etherex.block_number()
  on line 8 is expected to have type integer()
  but it has type
  {:ok, quantity()} | {:error, error()}

  $
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display, numbers=left
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0 #@\only<2->{:: integer()}

    invariants non_neg_height: height >= 0

    command block_number()#@\only<2->{ :: integer()} do
      post height == result
    end

    command mine()#@\only<2->{ :: :ok} do
      next height: height + 1
    end
  end
#+end_src

** Adding documentation

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<3->
#+attr_latex: :options style=shell
#+begin_src bash
  iex> h Blocks
  #@\onslide<4->
  Contains a Makina model called Blocks.

  Checks blocks are mined correctly.

  ## Commands

  - mine stored at Blocks.Command.Mine
  - block_number stored at Blocks.Command.BlockNumber

  ## State attributes

  - height

  ## Invariants

  - non_neg_height
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex
    #@ \onslide<2->
    @moduledoc """
    Checks blocks are mined correctly.
    """ #@ \onslide<1->
    state height: 0 :: integer()

    invariants non_neg_height: height >= 0

    command block_number() :: integer() do #@ \onslide<2->
      @moduledoc "Gets the block number." #@ \onslide<1->
      post {:ok, height} == result
    end

    command mine() :: :ok do #@ \onslide<2->
      @moduledoc "Mines a new block." #@ \onslide<1->
      next height: height + 1
    end
  end
#+end_src

** Adding documentation

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=shell
#+begin_src bash
  iex> h Blocks.Command.Mine
  #@\onslide<2->
  This module contains the functions necessary to
  generate and execute the command mine.

  Mines a new block.

  ## Definitions

  - next
  - call
  - weight
  - post
  - args
  - pre
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    @moduledoc """
    Checks blocks are mined correctly.
    """
    state height: 0 :: integer()

    invariants non_neg_height: height >= 0

    command block_number() :: integer() do
      @moduledoc "Gets the block number."
      post {:ok, height} == result
    end

    command mine() :: :ok do
      @moduledoc "Mines a new block."
      next height: height + 1
    end
  end
#+end_src

** Adding documentation

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=shell
#+begin_src bash
    iex> h Blocks.Command.Mine.post
    #@\onslide<2->
    This definition contains a predicate that should
    be true after the execution of mine

    ## Available variables

    ### State

      - state
      - height

    ### Arguments

      - arguments

    ### Result

      - result
#+end_src

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    @moduledoc """
    Checks blocks are mined correctly.
    """
    state height: 0 :: integer()

    invariants non_neg_height: height >= 0

    command block_number() :: integer() do
      @moduledoc "Gets the block number."
      post {:ok, height} == result
    end

    command mine() :: :ok do
      @moduledoc "Mines a new block."
      next height: height + 1
    end
  end
#+end_src

* Accounts model
** Account access
*** column
:properties:
:beamer_col: 0.28
:end:
#+beamer: \onslide<+->
The API:

| Command   | Returns   |
|-----------+-----------|
| =balance/1= | =integer()= |
#+beamer: \onslide<+->
\vspace{0.5cm}
1. create module.
   #+beamer: \onslide<+->
2. import =Makina=.
   #+beamer: \onslide<+->
3. define state.
   #+beamer: \onslide<+->
5. define commands.

*** column
:properties:
:beamer_col: 0.58
:end:

#+beamer: \onslide<2->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Accounts do #@\onslide<3->
    use Makina, implemented_by: Etherex
    #@\onslide<4->
    state accounts: Etherex.accounts() :: [address()],
          balances: Etherex.balances() :: %{address() => integer()}
    #@\onslide<5->
    command balance(account :: address()) :: integer() do
      pre accounts != []
      post balances[account] == result
    end #@\onslide<2->
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.28
:end:

#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test
  #@\onslide<+->
  ,** (Makina.Error) argument
      `account` missing in command
      get_balance
#+end_src
\vspace{40pt}

*** column
:properties:
:beamer_col: 0.58
:end:

#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
    defmodule Accounts do
      use Makina, implemented_by: Etherex

      state accounts: Etherex.accounts() :: [address()],
            balances: Etherex.balances() :: %{address() => integer()}

      command balance(account :: address()) :: integer() do
        pre accounts != []
        post balances[account] == result
      end
    end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.28
:end:

#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test

  ,** (Makina.Error) argument
      `account` missing in command
      get_balance
#+end_src
\vspace{40pt}

*** column
:properties:
:beamer_col: 0.58
:end:

#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Accounts do
    use Makina, implemented_by: Etherex

    state accounts: Etherex.accounts() :: [address()],
          balances: Etherex.balances() :: %{address() => integer()}

    command balance(account :: address()) :: integer() do
      args account: oneof(accounts)
      pre accounts != []
      post balances[account] == result
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.28
:end:

#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->
  #@\onslide<+->
  .........................
  .........................
  .........................
  .........................
  OK, passed 100 tests

  '100.0 Accounts.get_balance/1
#+end_src

*** column
:properties:
:beamer_col: 0.58
:end:

#+beamer: \onslide<1->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Accounts do
    use Makina, implemented_by: Etherex

    state accounts: Etherex.accounts() :: [address()],
          balances: Etherex.balances() :: %{address() => integer()}

    command balance(account :: address()) :: integer() do
      args account: oneof(accounts)
      pre accounts != []
      post balances[account] == result
    end
  end
#+end_src

* Transactions model
** Generating transactions
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
The API to generate and check transactions:
#+beamer: \onslide<+->
| Command        | Returns   |
|----------------+-----------|
| =mine/0=         | =:ok=       |
| =block_number/0= | =integer()= |
| =get_balance/1=  | =integer()= |
| =transfer/3=     | =hash()=    |
#+beamer: \onslide<+->
We can compose =Blocks= and =Accounts=!
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      extends: [Blocks, Accounts],
      implemented_by: Etherex
  end
#+end_src
#+beamer: \onslide<+->
Generates a model =Transactions.Composed=.

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  iex(1)> h Transactions.Composed
  #@\onslide<+->
  # Transactions.Composed

  ## Commands

   - mine stored
   - get_balance
   - block_number

  ## State attributes

   - height
   - balances
   - accounts

  ## Invariants

   - non_neg_height

#+end_src

** Generating transactions
*** column
:properties:
:beamer_col: 0.44
:end:
#+beamer: \onslide<+->
| Command        | Returns   |
|----------------+-----------|
| =transfer/3=     | =hash()=    |
*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next balances: update(balances, from, to, value)
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.44
:end:
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->

  transfer("0xffcf8fdee72ac11",
           "0x90f8bf6a479f320",
           1)
  block_number()

  Postcondition failed.

  block_number() -> {:ok, 1}

  Last state: %{height: 0, ...}
#+end_src

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next balances: update(balances, from, to, value)
    end
  end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.44
:end:
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->

  Postcondition failed.

  transfer("0xffcf8fdee72ac11",
           "0x90f8bf6a479f320",
           1)
  block_number() -> {:ok, 1}

  Last state: %{height: 0, ...}
#+end_src

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next height: height + 1,
           balances: update(balances, from, to, value)
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.44
:end:
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->

  transfer("0x90f8bf6a479f320",
           "0x90f8bf6a479f320",
           1),
  get_balance("0x90f8bf6a479f320")

  Postcondition failed.

  get_balance("0x90f8bf6a479f320")
  -> {:ok, 979000}

  Last state: %{
      balances: %{
          "0x90f8bf6a479f320" => 1000000
          .. }
      .. }
  #+end_src

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next height: height + 1,
           balances: update(balances, from, to, value)
    end
  end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.44
:end:
*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
    defmodule Transactions do
      use Makina,
        implemented_by: Etherex,
        extends: [Accounts, Blocks]

      command transfer(from, to, value) :: hash() do
        pre accounts != []
        args from: oneof(accounts),
             to: oneof(accounts),
             value: pos_integer()
        next height: height + 1,
             balances: update(balances, from, to, value)
      end
    end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.44
:end:

*** column
:properties:
:beamer_col: 0.52
:end:
#+beamer: \onslide<+->
\vspace{-10pt}
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      implemented_by: Etherex,
      extends: [Accounts, Blocks]

    state transactions: [] :: [symbolic(hash())]

    command transfer(from, to, value) :: hash() do
      pre accounts != []
      args from: oneof(accounts),
           to: oneof(accounts),
           value: pos_integer()
      next height: height + 1,
           transactions: [result | transactions],
           balances: update(balances, from, to, value)
                     |> symbolic(),
    end

    command get_balance() do
      pre transactions == []
    end
  end
#+end_src

** Fixing the model
*** column
:properties:
:beamer_col: 0.44
:end:

*** column
:properties:
:beamer_col: 0.52
:end:

#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions.GasCost do
    use Makina, extends: Transactions

    command gas_cost(hash :: hash())
        :: {address(), quantity()} do
      pre transactions != []
      args hash: oneof(transactions)
      next do
        from = symbolic(elem(result, 0))
        gas = symbolic(elem(result, 1))
        [transactions: List.delete(transactions, hash),
         balances: update(balances, from, gas)
                   |> symbolic()
        ]
      end
    end
  end
#+end_src

** Running the test
*** column
:properties:
:beamer_col: 0.44
:end:

#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test

  ..................................................
  ..................................................
  OK, passed 100 tests

  '25.5 Transactions.mine/0
  '24.9 Transactions.block_number/0
  '23.6 Transactions.transfer/3
  '14.3 Transactions.gas_cost/1
  '11.8 Transactions.get_balance/1
#+end_src

*** column
:properties:
:beamer_col: 0.52
:end:

#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions.GasCost do
    use Makina, extends: Transactions

    command gas_cost(hash :: hash())
        :: {address(), quantity()} do
      pre transactions != []
      args hash: oneof(transactions)
      next do
        from = symbolic(elem(result, 0))
        gas = symbolic(elem(result, 1))
        [transactions: List.delete(transactions, hash),
         balances: update(balances, from, gas)
                   |> symbolic()
        ]
      end
    end
  end
#+end_src
* Conclusions
** Results and conclussions

*** column
:properties:
:beamer_col: 0.38
:end:

Before Makina:
| files | blank | comment | code |
|-------+-------+---------+------|
|     4 |   760 |     383 | 4513 |

\vspace{10pt}

After Makina:
| files | blank | comment | code |
|-------+-------+---------+------|
|    18 |   500 |     408 | 1692 |

*** column
:properties:
:beamer_col: 0.58
:end:

Libraries:
- https://gitlab.com/babel-upm/makina/makina
- https://gitlab.com/babel-upm/blockchain/etherex

Slides and code:  
- https://gitlab.com/babel-upm/makina/code_beam_2022
