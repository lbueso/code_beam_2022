#+title: Improve your tests with Makina
#+author: Luis Eduardo Bueso de Barrio
#+setupfile: slides.setup
#+options: title:nil

\texturetheme

#+begin_export latex
\setbeamertemplate{title page}{
    \begin{columns}
      \begin{column}{0.55\textwidth}
        \center
        \includegraphics[width=\textwidth]{./template/logo-white}
      \end{column}
      \begin{column}{0.40\textwidth}
        \flushright
            {\Huge STOCKHOLM}

            \vspace{0.2cm}

            {\large HYBRID CONFERENCE}

            \vspace{1cm}

            {\Large \texttt{Improve your tests with Makina}}

            \vspace{1cm}

            Luis Eduardo Bueso de Barrio

            \vspace{0.5cm}

            \texttt{May 20 | 2022}
      \end{column}
    \end{columns}
}
#+end_export

\maketitle

\whitetheme

* Introduction
** The problem

*** column
:properties:
:beamer_col: 0.48
:end:

| files | blank | comment | code |
|-------+-------+---------+------|
|     4 |   760 |     383 | 4513 |

*** column
:properties:
:beamer_col: 0.48
:end:

| files | blank | comment | code |
|-------+-------+---------+------|
|    18 |   500 |     408 | 1692 |

* Introduction to PBT
** Introduction to PBT
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
Writing unit-tests is hard and time-consuming:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  reverse([]) == []
  reverse([1]) == [1]
  reverse([1 ,2]) == [2 ,1]
  ...
#+end_src
\vspace{10pt}
#+beamer: \onslide<+->
Property-Based Testing (PBT) philosophy:
#+beamer: \onslide<+->
#+begin_quote
Don't write tests, generate them.
#+end_quote


#+beamer: \onslide<+->
A test execution in PBT consists of:
#+beamer: \onslide<+->
  1. Data generation.
     #+beamer: \onslide<+->
  2. Property checking.
     #+beamer: \onslide<+->
  3. An shrinking strategy (if the property doesn't hold).
     #+beamer: \onslide<+->

*** column
:properties:
:beamer_col: 0.48
:end:
A property:
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  forall list <- list() do
    list == reverse(reverse(list))
  end
#+end_src
#+beamer: \onslide<+->
In each test:
1. =list()= generates a random list:
   #+beamer: \onslide<+->
   #+attr_latex: :options style=display
   #+begin_src elixir
  [8 ,10 ,6] ...
#+end_src
2. Checks the property:
   #+beamer: \onslide<+->
   #+attr_latex: :options style=display
   #+begin_src elixir
     [8, 10, 6] == reverse(reverse([8, 10, 6]))
   #+end_src
   #+beamer: \onslide<+->
3. If the property doesn't hold returns a counter-example.

** Testing /stateful/ programs
*** column
:properties:
:beamer_col: 0.38
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
Imagine a simple counter:
#+attr_latex: :align l l c
| Command | Returns            |
|---------+--------------------|
| =start/1= | =:ok= $\vert$ =:error= |
| =stop/0=  | =:ok= $\vert$ =:error= |
| =inc/0=   | =:ok=                |
| =get/0=   | =integer()=          |

#+beamer: \onslide<+->
Unit test:

#+attr_latex: :options style=display
#+begin_src elixir
  :ok = start(0)
  :ok = inc()
  1   = get()
  :ok = stop()
#+end_src

*** column
:properties:
:beamer_col: 0.58
:end:

#+beamer: \onslide<+->
This test can be represented:
#+begin_figure latex
\begin{center}
  \begin{adjustbox}{max width=\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick]

      \node[initial,state] (0) {$0$};

      \node[state] (1) [right of=0] {$1$};
      \path[] (0) edge node {\lstinline{inc()}} (1);

      \path[] (1) edge [loop right] node {\lstinline{get()}} (1);

      \node[state, accepting] (2) [right of=0] {};
    \end{tikzpicture}
  \end{adjustbox}
\end{center}
#+end_figure
#+beamer: \onslide<+->
To successfully test this program we need to:
   #+beamer: \onslide<+->
- Generate sequences of commands.
   #+beamer: \onslide<+->
- An internal state to track the changes in the program.
   #+beamer: \onslide<+->
- A way to interact with the program under test.

** PBT of /stateful/ programs
*** column
:properties:
:beamer_col: 0.58
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
Basic property of /stateful/ programs:
#+attr_latex: :options style=display
#+begin_src elixir
  forall cmds <- commands(Counter) do
    :ok == run_commands(Counter, cmds)
  end
#+end_src
#+beamer: \onslide<+->
where:
#+beamer: \onslide<+->
- =commands/1= generates sequences commands:
  #+attr_latex: :options style=display
  #+begin_src elixir
    [start(0), inc(), get(), stop()]
    ...
  #+end_src
  #+beamer: \onslide<+->
- =run_commands= executes the generated sequence.

*** column
:properties:
:beamer_col: 0.38
:end:
#+beamer: \onslide<+->
#+begin_figure latex
\begin{center}
  \begin{adjustbox}{max width=\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,semithick]

      \node[initial,state] (i0) {$0$};
      \node[state] (i1) [below of=i0] {$1$};
      \node[state] (i2) [below of=i1] {$1$};

      \path []
      (i0) edge node (inc)  [left] {\lstinline{inc()}} (i1)
      (i1) edge node (get)  [left] {\lstinline{get()}} (i2);

      % first call
      \node[] (inc_res)  [right of=inc, xshift=0.5cm] {\lstinline{:ok}};
      \path[] (inc) edge node (inc_call)  [sloped] {\lstinline{call}} (inc_res);
      \path[](inc_res)  edge node (inc_post) [sloped, below] {\lstinline{post}} (i1);

      % second call
      \node[] (get_res)  [right of=get, xshift=0.5cm] {\lstinline{1}};
      \path[] (get)  edge node (get_call)  [sloped] {\lstinline{call}} (get_res);
      \path[] (get_res)  edge node (get_post) [sloped, below] {\lstinline{post}} (i2);

      \node[state, accepting] (i3) [below of=i1]{};
    \end{tikzpicture}
  \end{adjustbox}
\end{center}
#+end_figure

** PBT state machines
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
Introduced by =Erlang QuickCheck=.
#+beamer: \onslide<+->
\vspace{10pt}


Adopted by other PBT libraries such as =Proper=.
#+beamer: \onslide<+->
\vspace{10pt}


These libraries provide a DSL to model the system.
#+beamer: \onslide<+->
\vspace{10pt}

Proven effectiveness.
*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
Very slow adoption.
\vspace{10pt}

#+beamer: \onslide<+->
Why?
\vspace{10pt}

#+beamer: \onslide<+->
Problems:
#+beamer: \onslide<+->
- Hard to write.
  #+beamer: \onslide<+->
- Cryptic errors.
  #+beamer: \onslide<+->
- Usually buggy.
  #+beamer: \onslide<+->
- Code reuse is very hard.
  #+beamer: \onslide<+->
- Hard to maintain.

* Introduction to Makina and running example
** Makina

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
=Makina= is a DSL to write PBT state machines.
#+beamer: \onslide<+->
- Fully compatible with =Erlang QuickCheck= and =PropEr=.
  #+beamer: \onslide<+->
- Improved usability.
  #+beamer: \onslide<+->
- Better error messages.
  #+beamer: \onslide<+->
- Improved error detection in models.

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
A Makina model contains:
#+beamer: \onslide<+->
- =state=
  #+beamer: \onslide<+->
- =command=
  #+beamer: \onslide<+->
- =invariants=
  #+beamer: \onslide<+->

\vspace{10pt}

Provides code reuse mechanisms:
#+beamer: \onslide<+->
- imports
  #+beamer: \onslide<+->  
- extends
  #+beamer: \onslide<+->
- composition

** Ethereum Blockchain

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
A blockchain is a distributed ledger that enables peer-to-peer transactions.
#+beamer: \onslide<+->
#+begin_figure latex
\begin{adjustbox}{max width=\textwidth}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
    distance=20,semithick, minimum width=70]

    \node (block0name) {\begin{tabular}{c} Block 0 \\ Genesis Block \end{tabular}};
    \node[rectangle, draw, below of=block0name] (block0index) {Index};
    \node[rectangle, draw, below of=block0index] (block0timestamp) {Timestamp};
    \node[rectangle, draw, below of=block0timestamp] (block0previoushash)
    {Previous Hash};
    \node[rectangle, draw, below of=block0previoushash] (block0hash)
    {Hash};
    \node[rectangle, draw, below of=block0hash] (block0data)
    {Data};

    \node [right of=block0name, yshift=-20, xshift=80] (block1name) {Block 1};
    \node[rectangle, draw, below of=block1name] (block1index) {Index};
    \node[rectangle, draw, below of=block1index] (block1timestamp) {Timestamp};
    \node[rectangle, draw, below of=block1timestamp] (block1previoushash)
    {Previous Hash};
    \node[rectangle, draw, below of=block1previoushash] (block1hash)
    {Hash};
    \node[rectangle, draw, below of=block1hash] (block1data)
    {Data};

    % \node [right of=block1name, yshift=-20, xshift=80] (block2name) {Block 2};
    % \node[rectangle, draw, below of=block2name] (block2index) {Index};
    % \node[rectangle, draw, below of=block2index] (block2timestamp) {Timestamp};
    % \node[rectangle, draw, below of=block2timestamp] (block2previoushash)
    % {Previous Hash};
    % \node[rectangle, draw, below of=block2previoushash] (block2hash)
    % {Hash};
    % \node[rectangle, draw, below of=block2hash] (block2data)
    % {Data};

    \node[right of=block1hash, xshift=40, minimum width=20] (block2previoushash)
    {...};

    \draw (block1previoushash) edge (block0hash);
    \draw (block2previoushash) edge (block1hash);

    \node[left  of=block0name, xshift=-20, yshift= 15] (block0a) {};
    \node[right of=block0data, xshift= 20, yshift=-13] (block0b) {};
    \draw[draw] (block0a) rectangle (block0b);

    \node[left  of=block1name, xshift=-20, yshift= 10] (block1a) {};
    \node[right of=block1data, xshift= 20, yshift=-13] (block1b) {};
    \draw[draw] (block1a) rectangle (block1b);

    % \node[left  of=block2name, xshift=-20, yshift= 10] (block2a) {};
    % \node[right of=block2data, xshift= 20, yshift=-10] (block2b) {};
    % \draw[draw] (block2a) rectangle (block2b);

  \end{tikzpicture}
\end{adjustbox}
#+end_figure

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
Ethereum is one of the largest blockchains.
#+beamer: \onslide<+->
\vspace{10pt}

Introduced smart-contracts.
#+beamer: \onslide<+->
\vspace{10pt}

=etherex= a library to interact with Ethereum using Elixir.
#+beamer: \onslide<+->
\vspace{10pt}

The properties to test:
#+beamer: \onslide<+->
1. Mining blocks.
   #+beamer: \onslide<+->
2. Account access.
   #+beamer: \onslide<+->
3. Transfers between accounts.

* Blocks model
** Mining blocks

*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<+->
#+beamer: \onslide<+->
The API:
#+beamer: \onslide<+->
| Command        | Returns          |
|----------------+------------------|
| =mine/0=         | =:ok=              |
| =block_number/0= | ={:ok, integer()}= |
#+beamer: \onslide<+->
\vspace{10pt}
1. create module.
   #+beamer: \onslide<+->
2. import =Makina=.
   #+beamer: \onslide<+->
3. define state.
   #+beamer: \onslide<+->
4. define invariants.
   #+beamer: \onslide<+->
5. define commands.
   #+beamer: \onslide<+->
6. introduce the callbacks.

*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<4->
#+attr_latex: :options style=display
#+begin_src elixir
    defmodule Blocks do #@ \onslide<5->
      use Makina, implemented_by: Etherex
      #@ \onslide<6->
      state height: 0
      #@ \onslide<7->
      invariants non_neg_height: height > 0
      #@ \onslide<8->
      command block_number() do #@ \onslide<9->
        pre true #@ \onslide<10->
        args [] #@ \onslide<11->
        valid_args true #@ \onslide<12->
        call Etherex.block_number #@ \onslide<13->
        next [] #@ \onslide<14->
        post {:ok, height} == result #@ \onslide<15->
      end
#+end_src

** Mining blocks

*** column
:properties:
:beamer_col: 0.48
:end:

The API:

| Command        | Returns          |
|----------------+------------------|
| =mine/0=         | =:ok=              |
| =block_number/0= | ={:ok, integer()}= |

\vspace{10pt}
1. create module.
2. import =Makina=.
3. define state.
4. define invariants.
5. define commands.
6. introduce the callbacks.

*** column
:properties:
:beamer_col: 0.48
:end:
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height > 0

    command block_number() do
      post {:ok, height} == result
    end
    #@ \onslide<2->
    command mine() :: :ok do
      next height: height + 1
    end
  end
#+end_src

** Auto generated documentation

#+beamer: \onslide<+->
#+beamer: \onslide<+->
When a model is compiled automatically generates documentation.
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src markdown
  iex> h Blocks
  #@ \onslide<+->
  # Blocks

  Contains a Makina model called Blocks.

  Specifies the mining facilities of the blockchain.

  ## Commands

  - mine stored at Blocks.Command.Mine
  - block_number stored at Blocks.Command.BlockNumber

  Detailed information about each command can be accessed inside the interpreter:

  iex> h Blocks.Command.NAME

  ## State attributes

  - height

  ...
#+end_src

** Auto generated documentation

When a model is compiled automatically generates documentation.
#+attr_latex: :options style=shell
#+begin_src markdown
  iex> h Blocks
  iex> h Blocks.Command.Mine.post
  #@ \onslide<2->
  ...
  ## Available variables

  ### State

  - state contains the complete dynamic state of the model.
  - height attribute defined in the state declaration.

  ### Arguments

  - arguments contains all the generated arguments of the command.

  ### Result

  - result variable that contains the result of the command execution.
#+end_src

** Adding type information

*** column
:properties:
:beamer_col: 0.58
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=display, numbers=left
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0 #@\onslide<3->{:: integer()}

    invariants non_neg_height: height >= 0

    command block_number() #@\onslide<4->{:: \{:ok, integer()\}} do
      post {:ok, height} == result
    end

    command mine() #@\onslide<4->{:: :ok} do
      call Etherex.Time.mine()
      next height: height + 1
    end
  end
#+end_src
#+beamer: \onslide<5->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix gradient
  #@\onslide<6->
  The function call Etherex.block_number() on line 8
  is expected to have type {:ok, quantity()}
  but it has type {:ok, quantity()} | {:error, error()}
#+end_src

** Adding documentation

#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex
    #@ \onslide<3->
    @moduledoc """
    Specifies the mining facilities of the blockchain.
    """
    #@ \onslide<2->
    state height: Etherex.block_number!() :: non_neg_integer()

    invariants non_genesis_block: height >= 0

    command block_number() :: {:ok, non_neg_integer()} do     #@ \onslide<3->
      @moduledoc "Retrieves the block number from the blockchain."    #@ \onslide<2->
      post {:ok, height} == result
    end

    command mine() :: :ok do    #@ \onslide<3->
      @moduledoc "Mines a new block."    #@ \onslide<2->
      call Etherex.Time.mine()
      next height: height + 1
    end
  end
#+end_src

** Running the test

#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@ \onslide<+->
  Starting Quviq QuickCheck version 1.45.1
  #@ \onslide<+->
  Failed! After 1 tests.
  [
      Blocks.block_number/0,
      Blocks.mine/0,
  ]

  ================================================================================
  Postcondition crashed:
  ,** (Makina.Error) invariant "non_neg_height" check failed

  Shrinking x.(1 times)
  [
      Blocks.block_number/0
  ]

  Last state: %{height: 0}

  Finished in 0.1 seconds (0.00s async, 0.1s sync)
  1 properties, 1 failure
#+end_src

** Fixing the model

*** column
:properties:
:beamer_col: 0.48
:end:

#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  Postcondition crashed:
  ,** invariant "non_neg_height" check failed

  Shrinking x.(1 times)
  [
      Blocks.block_number/0
  ]

  Last state: %{height: 0}
#+end_src

#+beamer: \onslide<+->
What happened?

\vspace{10pt}
#+beamer: \onslide<+->
Invariant doesn't hold even on the initial state!

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<2->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Blocks do
    use Makina, implemented_by: Etherex

    state height: 0

    invariants non_neg_height: height >#@\onslide<5->{=} 0

    command block_number() do
      post {:ok, height} == result
    end

    command mine() do
      call Etherex.Time.mine()
      next height: height + 1
    end
  end
#+end_src

** Running the test

#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->
  Starting Quviq QuickCheck version 1.45.1
  #@\onslide<+->
  ....................................................................................................
  OK, passed 100 tests

  51.5 Blocks.mine/0
  48.5 Blocks.block_number/0

  Finished in 8.6 seconds (0.00s async, 8.6s sync)
#+end_src

* Accounts model
** Account access

*** column
:properties:
:beamer_col: 0.28
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
The API:

| Command        | Returns          |
|----------------+------------------|
| =get_balance/1= | =:ok=              |
#+beamer: \onslide<+->
\vspace{0.5cm}
1. create module.
   #+beamer: \onslide<+->
2. import =Makina=.
   #+beamer: \onslide<+->
3. define state.
   #+beamer: \onslide<+->
4. define invariants.
   #+beamer: \onslide<+->
5. define commands.

*** column
:properties:
:beamer_col: 0.68
:end:

#+beamer: \onslide<3->
#+attr_latex: :options style=display
#+begin_src elixir
    defmodule Accounts do #@\onslide<4->
      use Makina, implemented_by: Etherex

      alias Etherex.Type
      #@\onslide<5->
      state accounts: Etherex.accounts!() :: [Type.address()],
            balances: Etherex.balances!() :: %{Type.address() => integer()}
      #@\onslide<7->
      command get_balance(account :: Type.address())
          :: {:ok, Type.quantity()} | {:error, Type.error()} do
        pre accounts != []
        post {:ok, balances[account]} == result
      end #@\onslide<4->
    end
#+end_src

** Running the test
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->
  Starting Quviq QuickCheck version 1.45.1
  #@\onslide<+->
  1) property Accounts (ExamplesTest)
     ,** (Makina.Error) argument `account` missing in command get_balance
     stacktrace:
     (makina 0.1.0) lib/makina/error.ex:9: Makina.Error.throw_error/1
     (examples 0.1.0) lib/accounts.ex:13: Accounts.Command.GetBalance.check_args/1
     (examples 0.1.0) lib/accounts.ex:1: Accounts.Behaviour.next_state/3
     Finished in 0.1 seconds (0.00s async, 0.1s sync)

     1 properties, 1 failure
#+end_src

** Fixing the model
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Accounts do
    use Makina, implemented_by: Etherex

    alias Etherex.Type

    state accounts: Etherex.accounts!() :: [Type.address()],
          balances: Etherex.balances!() :: %{Type.address() => integer()}

    command get_balance(account :: Type.address()) ::
        {:ok, Type.quantity()} | {:error, Type.error()} do
      pre accounts != []
      #@\onslide<3->{args account: oneof(accounts)}
      valid_args account in accounts
      post {:ok, balances[account]} == result
    end
  end
#+end_src

** Running the test
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->
  Starting Quviq QuickCheck version 1.45.1
  #@\onslide<+->
  ....................................................................................................
  OK, passed 100 tests

  '100.0 Accounts.get_balance/1

  Finished in 4.6 seconds (0.00s async, 4.6s sync)
  1 properties, 0 failures
#+end_src

* Transactions model
** Generating transactions

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
The API to generate and check transactions:
#+beamer: \onslide<+->
| Command           | Returns          |
|-------------------+------------------|
| =mine/0=            | =:ok=              |
| =block_number/0=    | ={:ok, integer()}= |
| =get_balance/1=     | ={:ok, integer()}= |
| =transfer/3=        | ={:ok, hash()}=    |
#+beamer: \onslide<+->
We can compose =Blocks= and =Accounts=!
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina,
      extends: [Blocks, Accounts],
      implemented_by: Etherex
  end
#+end_src
#+beamer: \onslide<+->
Generates a model =Transactions.Composed=.

*** column
:properties:
:beamer_col: 0.48
:end:
#+beamer: \onslide<+->
State is the union:
- =:height=
- =:accounts=
- =:balances=
#+beamer: \onslide<+->
\vspace{10pt}

Invariants are the union:
- =:non_genesis_block=
#+beamer: \onslide<+->
\vspace{10pt}

Commands are the union:
- =mine/0=
- =block_number/0=
- =get_balance/1=

** Generating transactions
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina, implemented_by: Etherex, extends: [Accounts, Blocks]
    alias Etherex.Type
    #@\onslide<+->
    command transfer(
      from :: Type.address(),
      to :: Type.address(),
      value :: Type.quantity()
    ) :: {:ok, Type.hash()} do #@\onslide<+->
      pre accounts != []#@\onslide<+->
      args from: oneof(accounts), to: oneof(accounts), value: pos_integer()#@\onslide<+->
      valid_args from in accounts and to in accounts#@\onslide<+->
      next balances: update_balances(balances, from, to, value) #@\onslide<3->
    end
    #@\onslide<+->
    def update_balances(balances, from, to, value) do
      balances
      |> Map.update!(from, fn balance - value end)
      |> Map.update!(to, fn balance + value end)
    end#@\onslide<2->
  end
#+end_src

** Running the test
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src display
  $ mix test #@\onslide<+->
  Starting Quviq QuickCheck version 1.45.1
  #@\onslide<+->
  Failed! After 1 tests.
  [
      Transactions.transfer("0xffcf8fdee72ac11b5c542428b35eef5769c409f0",
                            "0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1",
                            423319221061516289),
      Transactions.get_balance("0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1"),
      Transactions.mine(),
      Transactions.mine(),
      Transactions.block_number()
  ]

  ================================================================================
  Postcondition failed.

  ...

#+end_src

** Running the test

#+attr_latex: :options style=shell
#+begin_src bash
  Shrinking xxx.xx.x.x.x(4 times)
  #@\onslide<+->\onslide<+->
  [
      Transaction.transfer("0xffcf8fdee72ac11b5c542428b35eef5769c409f0",
                           "0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1",
                           1),
      Transactions.block_number()
  ]

  ================================================================================
  Postcondition failed.

  ...

  Transactions.block_number() -> {:ok, 1}


  Last state: %{height: 0, ...}

  Finished in 0.8 seconds (0.00s async, 0.8s sync)
  1 properties, 1 failure
#+end_src

** Fixing the transactions model
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=display
#+begin_src elixir
  defmodule Transactions do
    use Makina, implemented_by: Etherex, extends: [Accounts, Blocks]
    alias Etherex.Type

    command transfer(
      from :: Type.address(),
      to :: Type.address(),
      value :: Type.quantity()
    ) :: {:ok, Type.hash()} do
      pre accounts != []
      args from: oneof(accounts), to: oneof(accounts), value: pos_integer()
      valid_args from in accounts and to in accounts

      next balances: update_balances(balances, from, to, value),
           #@\onslide<+->{height: height + 1}
    end

    def update_balances(balances, from, to, value) do
      balances |> Map.update!(from, &(&1 - value)) |> Map.update!(to, &(&1 + value))
    end
  end
#+end_src

** Running the test
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->
  Starting Quviq QuickCheck version 1.45.1
  #@\onslide<+->
  ..Failed! After 2 tests.
  [
      ...
  ]

  ================================================================================
  Postcondition failed.

  ...

#+end_src

** Running the tests

#+attr_latex: :options style=shell
#+begin_src bash
  Shrinking xxxx.x.x.x.x.xx.x(6 times)
  #@\onslide<+->\onslide<+->
  [
      Transactions.transfer("0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1",
                            "0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1",
                            1),
      Transactions.get_balance("0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1")
  ]

  ================================================================================
  Postcondition failed.

  Transactions.get_balance("0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1")
  -> {:ok, 999999999999999999999999979000}

  Last state:
  %{ balances: %{ "0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1" => 1000000000000000000000000000000,
          ...
      },
      ...
  }
  Finished in 1.1 seconds (0.00s async, 1.1s sync)
  1 properties, 1 failure
#+end_src

** Fixing the transactions model

*** column
:properties:
:beamer_col: 0.38
:end:
#+beamer: \onslide<+->
#+beamer: \onslide<+->
Our model does not consider gas consumption.

\vspace{10pt}
#+beamer: \onslide<+->
We need to change:
1. A symbolic attribute to store transactions.
   #+beamer: \onslide<+->
2. =balances= needs to be symbolic.
   #+beamer: \onslide<+->
3. =get_balance/0= precondition.
   #+beamer: \onslide<+->

*** column
:properties:
:beamer_col: 0.58
:end:

   #+attr_latex: :options style=display
   #+begin_src elixir
     defmodule Transactions do
       ...
       state transactions: [] :: [symbolic(Type.hash())]
             balances: super()
               :: symbolic(%{Type.address() => integer()})

       command get_balance() do
         pre transactions == []
       end

       command transfer(...) do
         ...
         next transactions: [symbolic(elem(result, 1))
                             | transactions],
              ...
       end
   #+end_src

** Fixing the transactions model

#+beamer: \onslide<+->
#+beamer: \onslide<+->
=gas_cost/1= consults the consumed command and computes the new balances.

#+attr_latex: :options style=display
#+begin_src elixir
  command gas_cost(hash :: Type.hash()) :: {Type.address(), Type.quantity()} do
    pre transactions != []
    args hash: oneof(transactions)
    valid_args hash in transactions
    next do
      from = symbolic(elem(result, 0))
      gas = symbolic(elem(result, 1))
      [
        transactions: List.delete(transactions, hash),
        balances: discount_gas(balances, from, gas) |> symbolic()
      ]
    end
  end

#+end_src



** Running the tests
#+beamer: \onslide<+->
#+beamer: \onslide<+->
#+attr_latex: :options style=shell
#+begin_src bash
  $ mix test #@\onslide<+->
  Starting Quviq QuickCheck version 1.45.1
  #@\onslide<+->
  ....................................................................................................
  OK, passed 100 tests

  '25.5 Transactions.mine/0
  '24.9 Transactions.block_number/0
  '23.6 Transactions.transfer/3
  '14.3 Transactions.gas_cost/1
  '11.8 Transactions.get_balance/1

  Finished in 15.8 seconds (0.00s async, 15.8s sync)
  1 properties, 0 failures
#+end_src

* Conclusions
